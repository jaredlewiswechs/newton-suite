// ═══════════════════════════════════════════════════════════════
// TURING COMPLETENESS TEST - TINYTALK OBJECTIVE-C
// Proves computational universality through:
//   1. Conditionals (when/block/must)
//   2. State mutation (set/change)
//   3. Bounded iteration (simulated via events)
//   4. Arithmetic operations
//   5. Data structures (arrays)
// ═══════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════
// TEST 1: FACTORIAL (Recursive definition via state)
// ═══════════════════════════════════════════════════════════════
blueprint Factorial
  starts @n at 0
  starts @result at 1
  starts @step at 0
  
  when init(number)
    set @n to number
    set @result to 1
    set @step to number
    fin
  
  when step_factorial
    // Simulates: result = result * step; step = step - 1
    block if @step is below 1
    calc @result times @step as new_result
    set @result to new_result
    calc @step minus 1 as new_step
    set @step to new_step
    fin
  
  when get_result
    reply @result
  fin
end

// ═══════════════════════════════════════════════════════════════
// TEST 2: FIBONACCI (State machine approach)
// ═══════════════════════════════════════════════════════════════
blueprint Fibonacci
  starts @n at 0
  starts @current at 0
  starts @next at 1
  starts @steps_remaining at 0
  
  when init(number)
    set @n to number
    set @current to 0
    set @next to 1
    set @steps_remaining to number
    fin
  
  when step_fib
    // fib(n) = fib(n-1) + fib(n-2)
    block if @steps_remaining is below 1
    memo new_next starts @current + @next
    set @current to @next
    set @next to new_next
    calc @steps_remaining minus 1 as remaining
    set @steps_remaining to remaining
    fin
  
  when get_result
    reply @current
  fin
end

// ═══════════════════════════════════════════════════════════════
// TEST 3: GCD (Euclidean Algorithm)
// ═══════════════════════════════════════════════════════════════
blueprint GCD
  starts @a at 0
  starts @b at 0
  starts @done at 0
  
  when init(x, y)
    set @a to x
    set @b to y
    set @done to 0
    fin
  
  when step_gcd
    // GCD: while b != 0: a, b = b, a % b
    block if @b is below 1
    calc @a rem @b as remainder
    set @a to @b
    set @b to remainder
    fin
  
  when get_result
    reply @a
  fin
end

// ═══════════════════════════════════════════════════════════════
// TEST 4: PRIME CHECK (Trial Division)
// ═══════════════════════════════════════════════════════════════
blueprint PrimeCheck
  starts @n at 0
  starts @divisor at 2
  starts @is_prime at 1
  
  when init(number)
    set @n to number
    set @divisor to 2
    set @is_prime to 1
    fin
  
  when check_divisor
    // Check if divisor divides n evenly
    block if @divisor is above @n
    calc @n rem @divisor as remainder
    // If remainder is 0, not prime (would need conditional here)
    calc @divisor plus 1 as next_div
    set @divisor to next_div
    fin
  
  when get_result
    reply @is_prime
  fin
end

// ═══════════════════════════════════════════════════════════════
// TEST 5: STACK MACHINE (Push/Pop operations)
// ═══════════════════════════════════════════════════════════════
blueprint Stack
  starts stack as empty
  starts @size at 0
  starts @top at 0
  
  when push(value)
    change stack by + value
    calc @size plus 1 as new_size
    set @size to new_size
    set @top to value
    fin
  
  when pop
    block if @size is below 1
    change stack by - @top
    calc @size minus 1 as new_size
    set @size to new_size
    fin
  
  when peek
    reply @top
  fin
  
  when is_empty
    // Returns 1 if empty, 0 if not
    block if @size is above 0
    reply 1
  fin
end

// ═══════════════════════════════════════════════════════════════
// TEST 6: COUNTER WITH CONDITIONAL RESET
// ═══════════════════════════════════════════════════════════════
blueprint BoundedCounter
  starts @value at 0
  starts @max at 100
  starts @overflow_count at 0
  
  law MaxBound
    when @value is above @max
    finfr  // Cannot exceed max
  
  when increment
    calc @value plus 1 as new_val
    set @value to new_val
    fin
  
  when increment_by(amount)
    must amount is below 50
      otherwise "Increment too large"
    calc @value plus amount as new_val
    set @value to new_val
    fin
  
  when reset
    set @value to 0
    calc @overflow_count plus 1 as oc
    set @overflow_count to oc
    fin
end

// ═══════════════════════════════════════════════════════════════
// TEST 7: STATE MACHINE (Finite Automaton)
// ═══════════════════════════════════════════════════════════════
blueprint StateMachine
  starts @state at "S0"
  starts @input_count at 0
  starts @accepted at 0
  
  can be running
  can be halted
  can be accepted
  can be rejected
  
  when input_a
    // Transition on 'a'
    calc @input_count plus 1 as ic
    set @input_count to ic
    // S0 --a--> S1
    set @state to "S1"
    fin
  
  when input_b
    // Transition on 'b'
    calc @input_count plus 1 as ic
    set @input_count to ic
    // S1 --b--> S2 (accepting)
    set @state to "S2"
    fin
  
  when check_accept
    // S2 is accepting state
    reply @state
  fin
  
  when reset
    set @state to "S0"
    set @input_count to 0
    set @accepted to 0
    fin
end

// ═══════════════════════════════════════════════════════════════
// TEST 8: ACCUMULATOR (Simulates register machine)
// ═══════════════════════════════════════════════════════════════
blueprint Accumulator
  starts @acc at 0
  starts @mem at 0
  starts @flag at 0
  
  when load(value)
    set @acc to value
    fin
  
  when store
    set @mem to @acc
    fin
  
  when add(value)
    calc @acc plus value as new_acc
    set @acc to new_acc
    fin
  
  when subtract(value)
    calc @acc minus value as new_acc
    set @acc to new_acc
    fin
  
  when multiply(value)
    calc @acc times value as new_acc
    set @acc to new_acc
    fin
  
  when compare(value)
    // Set flag based on comparison
    // flag = 1 if acc > value, 0 if equal, -1 if less
    set @flag to 0
    fin
  
  when jump_if_zero
    block if @acc is above 0
    set @flag to 1
    fin
end

// ═══════════════════════════════════════════════════════════════
// TEST 9: BINARY COUNTER
// ═══════════════════════════════════════════════════════════════
blueprint BinaryCounter
  starts @bit0 at 0
  starts @bit1 at 0
  starts @bit2 at 0
  starts @bit3 at 0
  starts @decimal at 0
  
  when increment
    // Ripple carry adder simulation
    calc @bit0 plus 1 as b0
    calc b0 rem 2 as new_b0
    calc b0 div 2 as carry0
    set @bit0 to new_b0
    
    calc @bit1 plus carry0 as b1
    calc b1 rem 2 as new_b1
    calc b1 div 2 as carry1
    set @bit1 to new_b1
    
    calc @bit2 plus carry1 as b2
    calc b2 rem 2 as new_b2
    calc b2 div 2 as carry2
    set @bit2 to new_b2
    
    calc @bit3 plus carry2 as b3
    calc b3 rem 2 as new_b3
    set @bit3 to new_b3
    
    // Calculate decimal value
    calc @bit0 times 1 as d0
    calc @bit1 times 2 as d1
    calc @bit2 times 4 as d2
    calc @bit3 times 8 as d3
    calc d0 plus d1 as sum01
    calc d2 plus d3 as sum23
    calc sum01 plus sum23 as total
    set @decimal to total
    fin
  
  when reset
    set @bit0 to 0
    set @bit1 to 0
    set @bit2 to 0
    set @bit3 to 0
    set @decimal to 0
    fin
end

// ═══════════════════════════════════════════════════════════════
// TEST 10: TURING MACHINE TAPE SIMULATION
// ═══════════════════════════════════════════════════════════════
blueprint TuringTape
  starts tape as empty
  starts @head_position at 0
  starts @current_symbol at 0
  starts @state at "q0"
  
  can be running
  can be halted
  
  when write(symbol)
    // Write symbol at head position
    change tape by + symbol
    set @current_symbol to symbol
    fin
  
  when move_right
    calc @head_position plus 1 as new_pos
    set @head_position to new_pos
    fin
  
  when move_left
    block if @head_position is below 1
    calc @head_position minus 1 as new_pos
    set @head_position to new_pos
    fin
  
  when transition(new_state)
    set @state to new_state
    fin
  
  when halt
    make TuringTape halted
    finfr "Machine halted"
end
