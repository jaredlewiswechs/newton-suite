// ═══════════════════════════════════════════════════════════════
// ACID TEST - TINYTALK OBJECTIVE-C
// Tests Atomicity, Consistency, Isolation, Durability
// ═══════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════
// ATOMICITY TEST
// All operations in a when/forge must complete or all rollback
// ═══════════════════════════════════════════════════════════════

blueprint AtomicityTest
  starts @balance_a at 1000
  starts @balance_b at 1000
  starts @total at 2000
  starts @transfer_count at 0
  
  // Invariant: total should always equal balance_a + balance_b
  law ConservationOfFunds
    when @balance_a plus @balance_b is above @total
    finfr
  
  law NoNegativeBalance
    when @balance_a is below 0
    finfr
  
  when transfer(amount)
    // This should be atomic - either both happen or neither
    calc @balance_a minus amount as new_a
    set @balance_a to new_a
    // If this fails, balance_a should rollback
    must @balance_a is above 0
      otherwise "Insufficient funds in A"
    calc @balance_b plus amount as new_b
    set @balance_b to new_b
    calc @transfer_count plus 1 as tc
    set @transfer_count to tc
    fin
  
  when atomic_swap
    // Swap balances atomically
    memo temp starts @balance_a
    set @balance_a to @balance_b
    set @balance_b to temp
    fin
  
  when verify_invariant
    calc @balance_a plus @balance_b as computed_total
    must computed_total is @total
      otherwise "Conservation law violated!"
    reply :verified
  fin
end

// ═══════════════════════════════════════════════════════════════
// CONSISTENCY TEST
// Laws must be checked before AND after every operation
// ═══════════════════════════════════════════════════════════════

blueprint ConsistencyTest
  starts @value at 50
  starts @min at 0
  starts @max at 100
  
  // Value must always be in valid range
  law MinBound
    when @value is below @min
    finfr
  
  law MaxBound  
    when @value is above @max
    finfr
  
  when set_value(v)
    // This should fail if v violates laws
    set @value to v
    fin
  
  when increment
    calc @value plus 1 as new_val
    set @value to new_val
    fin
  
  when decrement
    calc @value minus 1 as new_val
    set @value to new_val
    fin
  
  when double_value
    // This might violate max bound
    calc @value times 2 as doubled
    set @value to doubled
    fin
  
  when halve_value
    calc @value div 2 as halved
    set @value to halved
    fin
end

// ═══════════════════════════════════════════════════════════════
// ISOLATION TEST
// Transactions should operate on snapshots
// ═══════════════════════════════════════════════════════════════

blueprint IsolationTest
  starts @counter at 0
  starts @snapshot_value at 0
  starts @dirty_read at 0
  
  when start_transaction
    // Capture snapshot at start
    set @snapshot_value to @counter
    fin
  
  when read_counter
    reply @counter
  fin
  
  when increment_counter
    calc @counter plus 1 as c
    set @counter to c
    fin
  
  when check_isolation
    // Verify snapshot wasn't affected by other changes
    calc @counter minus @snapshot_value as diff
    set @dirty_read to diff
    fin
  
  when simulate_concurrent_update
    // Simulates what would happen with concurrent access
    calc @counter plus 10 as c
    set @counter to c
    fin
end

// ═══════════════════════════════════════════════════════════════
// DURABILITY TEST
// Committed changes must persist
// ═══════════════════════════════════════════════════════════════

blueprint DurabilityTest
  starts @committed_value at 0
  starts @uncommitted_value at 0
  starts @commit_count at 0
  
  when prepare(value)
    // Prepare but don't commit
    set @uncommitted_value to value
    fin
  
  when commit
    // Make the change permanent
    set @committed_value to @uncommitted_value
    calc @commit_count plus 1 as cc
    set @commit_count to cc
    fin
  
  when rollback
    // Discard uncommitted changes
    set @uncommitted_value to @committed_value
    fin
  
  when verify_durability
    // Committed value should persist
    must @committed_value is @committed_value
      otherwise "Durability violation!"
    reply @commit_count
  fin
end

// ═══════════════════════════════════════════════════════════════
// BANK ACCOUNT - COMPREHENSIVE ACID TEST
// ═══════════════════════════════════════════════════════════════

blueprint BankAccount
  starts @balance at 0
  starts @pending at 0
  starts @transaction_log_count at 0
  starts @overdraft_limit at 0
  
  can be active
  can be frozen
  can be closed
  
  // CONSISTENCY: Balance can never go below overdraft limit
  law NoOverdraft
    when @balance is below @overdraft_limit
    finfr
  
  // CONSISTENCY: Pending cannot exceed balance
  law PendingLimit
    when @pending is above @balance
    finfr
  
  forge deposit(amount)
    // ATOMICITY: All or nothing
    must amount is above 0
      otherwise "Invalid deposit amount"
    calc @balance plus amount as new_balance
    set @balance to new_balance
    calc @transaction_log_count plus 1 as tlc
    set @transaction_log_count to tlc
    reply :deposited
  end
  
  forge withdraw(amount)
    // ATOMICITY: Must pass all checks before withdrawal
    must amount is above 0
      otherwise "Invalid withdrawal amount"
    must @balance is above amount
      otherwise "Insufficient funds"
    calc @balance minus amount as new_balance
    set @balance to new_balance
    calc @transaction_log_count plus 1 as tlc
    set @transaction_log_count to tlc
    reply :withdrawn
  end
  
  forge transfer_out(amount, destination)
    // ATOMICITY: Complex multi-step operation
    must amount is above 0
      otherwise "Invalid transfer amount"
    must @balance is above amount
      otherwise "Insufficient funds for transfer"
    
    // Debit this account
    calc @balance minus amount as new_balance
    set @balance to new_balance
    
    // Log the transaction
    calc @transaction_log_count plus 1 as tlc
    set @transaction_log_count to tlc
    
    reply :transferred
  end
  
  forge hold_funds(amount)
    // Place a hold (pending) on funds
    must amount is above 0
      otherwise "Invalid hold amount"
    calc @balance minus @pending as available
    must available is above amount
      otherwise "Insufficient available funds"
    calc @pending plus amount as new_pending
    set @pending to new_pending
    reply :held
  end
  
  forge release_hold(amount)
    // Release a hold
    must @pending is above amount
      otherwise "No such hold exists"
    calc @pending minus amount as new_pending
    set @pending to new_pending
    reply :released
  end
  
  forge close_account
    // Can only close if no pending and no balance
    must @pending is below 1
      otherwise "Cannot close with pending transactions"
    must @balance is below 1
      otherwise "Cannot close with remaining balance"
    make BankAccount closed
    finfr "Account closed permanently"
  end
end

// ═══════════════════════════════════════════════════════════════
// INVENTORY SYSTEM - ACID WITH MULTIPLE ENTITIES
// ═══════════════════════════════════════════════════════════════

blueprint Inventory
  starts @quantity at 0
  starts @reserved at 0
  starts @min_stock at 5
  starts @max_stock at 1000
  
  // CONSISTENCY: Can't have negative inventory
  law NoNegativeStock
    when @quantity is below 0
    finfr
  
  // CONSISTENCY: Reserved can't exceed quantity
  law ReservedLimit
    when @reserved is above @quantity
    finfr
  
  // CONSISTENCY: Can't exceed max stock
  law MaxStockLimit
    when @quantity is above @max_stock
    finfr
  
  forge receive_shipment(amount)
    must amount is above 0
      otherwise "Invalid shipment quantity"
    calc @quantity plus amount as new_qty
    set @quantity to new_qty
    reply :received
  end
  
  forge reserve_stock(amount)
    calc @quantity minus @reserved as available
    must available is above amount
      otherwise "Insufficient stock to reserve"
    calc @reserved plus amount as new_reserved
    set @reserved to new_reserved
    reply :reserved
  end
  
  forge fulfill_reservation(amount)
    must @reserved is above amount
      otherwise "No such reservation"
    calc @reserved minus amount as new_reserved
    set @reserved to new_reserved
    calc @quantity minus amount as new_qty
    set @quantity to new_qty
    reply :fulfilled
  end
  
  forge cancel_reservation(amount)
    must @reserved is above amount
      otherwise "No such reservation to cancel"
    calc @reserved minus amount as new_reserved
    set @reserved to new_reserved
    reply :cancelled
  end
  
  forge check_reorder
    calc @quantity minus @reserved as available
    block if available is above @min_stock
    reply :needs_reorder
  fin
end

// ═══════════════════════════════════════════════════════════════
// DOUBLE-ENTRY BOOKKEEPING - ULTIMATE ACID TEST
// ═══════════════════════════════════════════════════════════════

blueprint Ledger
  starts @debits at 0
  starts @credits at 0
  starts @entry_count at 0
  
  // FUNDAMENTAL ACCOUNTING EQUATION
  // Debits must always equal credits
  law BalancedBooks
    when @debits is above @credits
    finfr
  
  forge journal_entry(debit_amount, credit_amount)
    // Both sides must match
    must debit_amount is credit_amount
      otherwise "Unbalanced entry rejected"
    
    calc @debits plus debit_amount as new_debits
    set @debits to new_debits
    
    calc @credits plus credit_amount as new_credits
    set @credits to new_credits
    
    calc @entry_count plus 1 as ec
    set @entry_count to ec
    
    reply :posted
  end
  
  forge verify_balance
    must @debits is @credits
      otherwise "Books are unbalanced!"
    reply :balanced
  fin
end
