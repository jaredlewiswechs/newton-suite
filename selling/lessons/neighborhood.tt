// Neighborhood Builder — TinyTalk demo
law generateNeighborhood(n, width, height)
    let xs = []
    let ys = []
    let demand = []
    let base = []
    for i in range(n) {
        let x = (i * 37) % width
        let y = (i * 61) % height
        let d = 5 + ((i * 13) % 15)
        let b = 1200 + ((i * 29) % 800)
        push(xs, x)
        push(ys, y)
        push(demand, d)
        push(base, b)
    }
    reply [xs, ys, demand, base]
end

law baselineCost(n, base)
    let solar_per_house = 4000
    let battery_per_house = 1500
    let maint_per_house = 150
    let total = 0
    for i in range(n) { total = total + (base[i] + solar_per_house + battery_per_house + maint_per_house) }
    reply total
end

law greedyClusters(n, xs, ys, radius)
    let assigned = []
    for i in range(n) { push(assigned, false) }
    let clusters = []
    for i in range(n) {
        if assigned[i] { continue }
        let cluster = []
        for j in range(n) {
            if assigned[j] { continue }
            let dx = xs[i] - xs[j]
            let dy = ys[i] - ys[j]
            let d2 = dx * dx + dy * dy
            if d2 <= radius * radius {
                push(cluster, j)
                assigned[j] = true
            }
        }
        push(clusters, cluster)
    }
    reply clusters
end

law clusteredCost(clusters, demand, base)
    let per_kwh_solar_cost = 200
    let battery_cost_per_kwh = 100
    let wiring_per_house = 300
    let total = 0
    for c in clusters {
        let agg = 0
        let size = len(c)
        for idx in c { agg = agg + demand[idx] }
        let solar_factor = 1 - 0.03 * size
        if solar_factor < 0.6 { solar_factor = 0.6 }
        let solar_capacity_kwh = agg * 0.9
        let solar_capacity_cost = solar_capacity_kwh * per_kwh_solar_cost * solar_factor
        let battery_factor = 1 - 0.02 * size
        if battery_factor < 0.7 { battery_factor = 0.7 }
        let battery_kwh = agg * 0.6
        let battery_cost = battery_kwh * battery_cost_per_kwh * battery_factor
        let cluster_fixed = 1200 + 80 * size
        let base_sum = 0
        for idx in c { base_sum = base_sum + base[idx] }
        let cluster_total = solar_capacity_cost + battery_cost + cluster_fixed + (wiring_per_house * size) + base_sum
        let maint = 200 * (size ^ 0.5)
        cluster_total = cluster_total + maint
        total = total + cluster_total
    }
    reply total
end

let n = 24
let areaW = 1000
let areaH = 800
let data = generateNeighborhood(n, areaW, areaH)
let xs = data[0]
let ys = data[1]
let demand = data[2]
let base = data[3]

let radii = [30, 60, 100, 160, 240]
let bestRadius = -1
let bestAvg = 1e99
let bestTotal = 0
let bestClusters = []
let baseTotal = baselineCost(n, base)
for r in radii {
    let clusters = greedyClusters(n, xs, ys, r)
    let total = clusteredCost(clusters, demand, base)
    let avg = total / n
    if avg < bestAvg {
        bestAvg = avg
        bestRadius = r
        bestTotal = total
        bestClusters = clusters
    }
}

show("Neighborhood simulation — Community Clustering")
show("Homes: " + n)
show("Baseline total cost (everyone separate): $" + baseTotal)
show("Best clustering radius: " + bestRadius)
show("Total cost with clustering: $" + bestTotal)
show("Average per-house cost: $" + bestAvg)
show("Estimated savings per house: $" + ((baseTotal / n) - bestAvg))
show("Savings percent (vs baseline): " + ((1 - (bestTotal / baseTotal)) * 100) + "%")
show("--- Cluster breakdown ---")

// Summarize small
for c in bestClusters { show(c) }
