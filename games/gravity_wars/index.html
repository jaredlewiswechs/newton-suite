<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gravity Wars - Newton Physics Roguelike</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0f;
            color: #fff;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        .game-header {
            text-align: center;
            padding: 15px;
            background: linear-gradient(180deg, #1a1a2e 0%, #0a0a0f 100%);
            width: 100%;
        }

        .game-header h1 {
            font-size: 2rem;
            background: linear-gradient(135deg, #00ff88, #00aaff, #ff00aa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 5px;
        }

        .game-header p {
            font-size: 0.8rem;
            color: #666;
        }

        .game-container {
            position: relative;
            margin: 10px;
        }

        #gameCanvas {
            border: 2px solid #333;
            border-radius: 8px;
            background: #0f0f1a;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.1);
        }

        .hud {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.85rem;
            border: 1px solid #333;
        }

        .hud-item {
            margin: 5px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .hud-label {
            color: #888;
            min-width: 80px;
        }

        .hud-value {
            color: #00ff88;
            font-weight: bold;
        }

        .health-bar {
            width: 100px;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
        }

        .health-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0044, #ff4400, #00ff88);
            transition: width 0.3s;
        }

        .verification-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid #00ff88;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.7rem;
        }

        .verification-badge .label {
            color: #00ff88;
        }

        .controls {
            margin-top: 15px;
            text-align: center;
            color: #666;
            font-size: 0.8rem;
        }

        .controls kbd {
            background: #222;
            border: 1px solid #444;
            padding: 2px 8px;
            border-radius: 4px;
            margin: 0 3px;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            border: 2px solid #ff0044;
            display: none;
        }

        .game-over h2 {
            color: #ff0044;
            font-size: 2rem;
            margin-bottom: 20px;
        }

        .game-over .final-score {
            font-size: 3rem;
            color: #00ff88;
            margin: 20px 0;
        }

        .game-over button {
            background: linear-gradient(135deg, #00ff88, #00aaff);
            border: none;
            padding: 15px 40px;
            font-size: 1.2rem;
            border-radius: 8px;
            cursor: pointer;
            font-family: inherit;
            margin-top: 20px;
        }

        .wave-announce {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            color: #00ff88;
            text-shadow: 0 0 20px #00ff88;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }

        .wave-announce.visible {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="game-header">
        <h1>GRAVITY WARS</h1>
        <p>Newton Constraint-Verified Physics Roguelike</p>
    </div>

    <div class="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>

        <div class="hud">
            <div class="hud-item">
                <span class="hud-label">HEALTH</span>
                <div class="health-bar">
                    <div class="health-bar-fill" id="healthBar" style="width: 100%"></div>
                </div>
            </div>
            <div class="hud-item">
                <span class="hud-label">SCORE</span>
                <span class="hud-value" id="scoreValue">0</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">WAVE</span>
                <span class="hud-value" id="waveValue">1</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">G-BOMBS</span>
                <span class="hud-value" id="bombsValue">3</span>
            </div>
        </div>

        <div class="verification-badge">
            <div class="label">NEWTON VERIFIED</div>
            <div id="stateHash">Hash: ...</div>
        </div>

        <div class="wave-announce" id="waveAnnounce">WAVE 1</div>

        <div class="game-over" id="gameOver">
            <h2>GAME OVER</h2>
            <p>Your score:</p>
            <div class="final-score" id="finalScore">0</div>
            <p id="wavesCleared">Waves cleared: 0</p>
            <button onclick="restartGame()">PLAY AGAIN</button>
        </div>
    </div>

    <div class="controls">
        <kbd>WASD</kbd> Move |
        <kbd>Mouse</kbd> Aim |
        <kbd>Click</kbd> Shoot |
        <kbd>Space</kbd> Gravity Bomb |
        <kbd>R</kbd> Restart
    </div>

    <script>
        // ═══════════════════════════════════════════════════════════════════════
        // GRAVITY WARS - Newton Physics Roguelike (JavaScript Port)
        // All game logic is constraint-verified before execution
        // ═══════════════════════════════════════════════════════════════════════

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game constants (changing these changes the game hash!)
        const CONSTANTS = {
            ARENA_WIDTH: 800,
            ARENA_HEIGHT: 600,
            GRAVITY_DEFAULT: 400,
            MAX_SPEED: 400,
            FRICTION: 0.92,
            PLAYER_SIZE: 20,
            PLAYER_MAX_HEALTH: 100,
            PLAYER_SPEED: 800,
            PROJECTILE_SPEED: 600,
            PROJECTILE_DAMAGE: 15,
            GRAVITY_BOMB_RADIUS: 150,
            GRAVITY_BOMB_DURATION: 3,
            ENEMIES_PER_WAVE_BASE: 3,
        };

        // Generate constants hash
        function getConstantsHash() {
            const data = Object.values(CONSTANTS).join(':');
            let hash = 0;
            for (let i = 0; i < data.length; i++) {
                hash = ((hash << 5) - hash) + data.charCodeAt(i);
                hash = hash & hash;
            }
            return Math.abs(hash).toString(16).toUpperCase().slice(0, 8);
        }

        // ═══════════════════════════════════════════════════════════════════════
        // CONSTRAINT ENGINE
        // ═══════════════════════════════════════════════════════════════════════

        class ConstraintEngine {
            constructor() {
                this.boundaries = [];
            }

            addBoundary(checkFn, name) {
                this.boundaries.push({ check: checkFn, name });
            }

            verify(entity, newX, newY, newVx, newVy) {
                const delta = {
                    x: { from: entity.x, to: newX, delta: newX - entity.x },
                    y: { from: entity.y, to: newY, delta: newY - entity.y },
                    vx: { from: entity.vx || 0, to: newVx, delta: newVx - (entity.vx || 0) },
                    vy: { from: entity.vy || 0, to: newVy, delta: newVy - (entity.vy || 0) },
                };

                for (const boundary of this.boundaries) {
                    if (boundary.check(delta)) {
                        return { allowed: false, reason: boundary.name };
                    }
                }
                return { allowed: true, reason: 'OK' };
            }
        }

        // ═══════════════════════════════════════════════════════════════════════
        // GAME STATE
        // ═══════════════════════════════════════════════════════════════════════

        let gameState = {
            running: false,
            frame: 0,
            time: 0,
            wave: 1,
            enemiesKilled: 0,
            seed: Date.now(),
            stateHashes: [],
        };

        let player = null;
        let enemies = [];
        let projectiles = [];
        let gravityWells = [];
        let particles = [];

        // Input state
        let keys = {};
        let mouse = { x: 0, y: 0, down: false };

        // Constraint engine
        const constraints = new ConstraintEngine();

        // Setup constraints
        constraints.addBoundary(d => d.x.to < 0, 'LeftWall');
        constraints.addBoundary(d => d.x.to > CONSTANTS.ARENA_WIDTH, 'RightWall');
        constraints.addBoundary(d => d.y.to < 0, 'TopWall');
        constraints.addBoundary(d => d.y.to > CONSTANTS.ARENA_HEIGHT, 'BottomWall');
        constraints.addBoundary(d => Math.abs(d.vx.to) > CONSTANTS.MAX_SPEED * 1.5, 'SpeedLimitX');
        constraints.addBoundary(d => Math.abs(d.vy.to) > CONSTANTS.MAX_SPEED * 1.5, 'SpeedLimitY');

        // ═══════════════════════════════════════════════════════════════════════
        // ENTITY CLASSES
        // ═══════════════════════════════════════════════════════════════════════

        class Entity {
            constructor(x, y, size = 20) {
                this.id = Math.random().toString(36).slice(2);
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.size = size;
                this.health = 100;
                this.maxHealth = 100;
                this.alive = true;
                this.gravityScale = 1;
            }

            move(newX, newY, newVx, newVy) {
                const result = constraints.verify(this, newX, newY, newVx, newVy);

                if (result.allowed) {
                    this.x = newX;
                    this.y = newY;
                    this.vx = newVx;
                    this.vy = newVy;
                    return true;
                } else {
                    // Clamp to boundaries
                    this.x = Math.max(this.size/2, Math.min(CONSTANTS.ARENA_WIDTH - this.size/2, newX));
                    this.y = Math.max(this.size/2, Math.min(CONSTANTS.ARENA_HEIGHT - this.size/2, newY));
                    this.vx = 0;
                    this.vy = 0;
                    return false;
                }
            }

            collidesWith(other) {
                const dx = this.x - other.x;
                const dy = this.y - other.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                return dist < (this.size + other.size) / 2;
            }
        }

        class Player extends Entity {
            constructor(x, y) {
                super(x, y, CONSTANTS.PLAYER_SIZE);
                this.health = CONSTANTS.PLAYER_MAX_HEALTH;
                this.maxHealth = CONSTANTS.PLAYER_MAX_HEALTH;
                this.score = 0;
                this.combo = 0;
                this.gravityBombs = 3;
                this.invincibilityTimer = 0;
                this.shootCooldown = 0;
            }
        }

        class Enemy extends Entity {
            constructor(x, y, wave) {
                super(x, y, 25 + wave * 2);
                this.health = 30 + wave * 10;
                this.maxHealth = this.health;
                this.behavior = ['chase', 'chase', 'patrol', 'sniper'][Math.floor(Math.random() * 4)];
                this.reactionTime = Math.max(0.2, 0.8 - wave * 0.05);
                this.lastAction = 0;
                this.color = this.behavior === 'sniper' ? '#ff4400' :
                             this.behavior === 'patrol' ? '#ffaa00' : '#ff0066';
            }
        }

        class Projectile extends Entity {
            constructor(x, y, vx, vy, ownerId, isPlayer) {
                super(x, y, 6);
                this.vx = vx;
                this.vy = vy;
                this.ownerId = ownerId;
                this.isPlayer = isPlayer;
                this.damage = CONSTANTS.PROJECTILE_DAMAGE;
                this.lifetime = 3;
            }
        }

        class GravityWell {
            constructor(x, y, reverse = true) {
                this.x = x;
                this.y = y;
                this.radius = CONSTANTS.GRAVITY_BOMB_RADIUS;
                this.modifier = reverse ? -1 : 2;
                this.duration = CONSTANTS.GRAVITY_BOMB_DURATION;
                this.createdAt = gameState.time;
            }
        }

        class Particle {
            constructor(x, y, vx, vy, color, size, lifetime) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.size = size;
                this.lifetime = lifetime;
                this.maxLifetime = lifetime;
            }
        }

        // ═══════════════════════════════════════════════════════════════════════
        // GAME LOGIC
        // ═══════════════════════════════════════════════════════════════════════

        function initGame() {
            gameState = {
                running: true,
                frame: 0,
                time: 0,
                wave: 1,
                enemiesKilled: 0,
                seed: Date.now(),
                stateHashes: [],
            };

            player = new Player(CONSTANTS.ARENA_WIDTH / 2, CONSTANTS.ARENA_HEIGHT / 2);
            enemies = [];
            projectiles = [];
            gravityWells = [];
            particles = [];

            document.getElementById('gameOver').style.display = 'none';
            announceWave(1);
        }

        function getLocalGravity(x, y) {
            let gravityY = CONSTANTS.GRAVITY_DEFAULT;

            for (const well of gravityWells) {
                const dx = x - well.x;
                const dy = y - well.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < well.radius) {
                    const influence = 1 - (dist / well.radius);
                    gravityY *= well.modifier * influence + (1 - influence);
                }
            }

            return gravityY;
        }

        function spawnEnemy() {
            const edges = ['top', 'bottom', 'left', 'right'];
            const edge = edges[Math.floor(Math.random() * 4)];
            let x, y;

            switch(edge) {
                case 'top':
                    x = 50 + Math.random() * (CONSTANTS.ARENA_WIDTH - 100);
                    y = 30;
                    break;
                case 'bottom':
                    x = 50 + Math.random() * (CONSTANTS.ARENA_WIDTH - 100);
                    y = CONSTANTS.ARENA_HEIGHT - 30;
                    break;
                case 'left':
                    x = 30;
                    y = 50 + Math.random() * (CONSTANTS.ARENA_HEIGHT - 100);
                    break;
                case 'right':
                    x = CONSTANTS.ARENA_WIDTH - 30;
                    y = 50 + Math.random() * (CONSTANTS.ARENA_HEIGHT - 100);
                    break;
            }

            enemies.push(new Enemy(x, y, gameState.wave));
        }

        function fireProjectile(owner, targetX, targetY, isPlayer) {
            const dx = targetX - owner.x;
            const dy = targetY - owner.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist === 0) return;

            const vx = (dx / dist) * CONSTANTS.PROJECTILE_SPEED;
            const vy = (dy / dist) * CONSTANTS.PROJECTILE_SPEED;

            projectiles.push(new Projectile(owner.x, owner.y, vx, vy, owner.id, isPlayer));

            // Muzzle flash particles
            for (let i = 0; i < 5; i++) {
                const angle = Math.atan2(dy, dx) + (Math.random() - 0.5) * 0.5;
                const speed = 100 + Math.random() * 100;
                particles.push(new Particle(
                    owner.x, owner.y,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    isPlayer ? '#00ff88' : '#ff4400',
                    3 + Math.random() * 2,
                    0.2
                ));
            }
        }

        function createGravityWell(x, y) {
            if (player.gravityBombs <= 0) return;

            player.gravityBombs--;
            gravityWells.push(new GravityWell(x, y, true));

            // Explosion particles
            for (let i = 0; i < 30; i++) {
                const angle = (i / 30) * Math.PI * 2;
                const speed = 200 + Math.random() * 200;
                particles.push(new Particle(
                    x, y,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    '#00aaff',
                    4 + Math.random() * 3,
                    0.5
                ));
            }
        }

        function updatePlayer(dt) {
            if (!player.alive) return;

            // Apply gravity
            const gravity = getLocalGravity(player.x, player.y);
            let newVy = player.vy + gravity * dt;
            let newVx = player.vx;

            // Input
            if (keys['w'] || keys['ArrowUp']) newVy -= CONSTANTS.PLAYER_SPEED * dt;
            if (keys['s'] || keys['ArrowDown']) newVy += CONSTANTS.PLAYER_SPEED * dt * 0.5;
            if (keys['a'] || keys['ArrowLeft']) newVx -= CONSTANTS.PLAYER_SPEED * dt;
            if (keys['d'] || keys['ArrowRight']) newVx += CONSTANTS.PLAYER_SPEED * dt;

            // Friction
            newVx *= CONSTANTS.FRICTION;
            newVy *= CONSTANTS.FRICTION;

            // Clamp velocity
            const speed = Math.sqrt(newVx * newVx + newVy * newVy);
            if (speed > CONSTANTS.MAX_SPEED) {
                newVx = (newVx / speed) * CONSTANTS.MAX_SPEED;
                newVy = (newVy / speed) * CONSTANTS.MAX_SPEED;
            }

            // Move with constraint verification
            const newX = player.x + newVx * dt;
            const newY = player.y + newVy * dt;
            player.move(newX, newY, newVx, newVy);

            // Shooting
            player.shootCooldown -= dt;
            if (mouse.down && player.shootCooldown <= 0) {
                fireProjectile(player, mouse.x, mouse.y, true);
                player.shootCooldown = 0.15;
            }

            // Invincibility
            if (player.invincibilityTimer > 0) {
                player.invincibilityTimer -= dt;
            }
        }

        function updateEnemies(dt) {
            for (const enemy of enemies) {
                if (!enemy.alive) continue;

                // Apply gravity
                const gravity = getLocalGravity(enemy.x, enemy.y);
                let newVy = enemy.vy + gravity * dt;
                let newVx = enemy.vx;

                // AI behavior
                enemy.lastAction += dt;
                if (enemy.lastAction >= enemy.reactionTime && player.alive) {
                    enemy.lastAction = 0;

                    const dx = player.x - enemy.x;
                    const dy = player.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (enemy.behavior === 'chase') {
                        newVx += (dx / dist) * 200;
                        newVy += (dy / dist) * 100;
                    } else if (enemy.behavior === 'patrol') {
                        newVx += (Math.random() - 0.5) * 150;
                        newVy += (Math.random() - 0.5) * 100;
                    } else if (enemy.behavior === 'sniper') {
                        if (dist > 200) {
                            fireProjectile(enemy, player.x, player.y, false);
                        } else {
                            // Retreat
                            newVx -= (dx / dist) * 150;
                        }
                    }
                }

                // Friction
                newVx *= CONSTANTS.FRICTION;
                newVy *= CONSTANTS.FRICTION;

                // Move with constraint verification
                const newX = enemy.x + newVx * dt;
                const newY = enemy.y + newVy * dt;
                enemy.move(newX, newY, newVx, newVy);
            }
        }

        function updateProjectiles(dt) {
            for (const proj of projectiles) {
                // Slight gravity effect
                const gravity = getLocalGravity(proj.x, proj.y) * 0.2;
                proj.vy += gravity * dt;

                proj.x += proj.vx * dt;
                proj.y += proj.vy * dt;
                proj.lifetime -= dt;

                // Check bounds
                if (proj.x < 0 || proj.x > CONSTANTS.ARENA_WIDTH ||
                    proj.y < 0 || proj.y > CONSTANTS.ARENA_HEIGHT ||
                    proj.lifetime <= 0) {
                    proj.alive = false;
                }
            }

            projectiles = projectiles.filter(p => p.alive);
        }

        function updateGravityWells(dt) {
            gravityWells = gravityWells.filter(w =>
                gameState.time - w.createdAt < w.duration
            );
        }

        function updateParticles(dt) {
            for (const p of particles) {
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.vx *= 0.95;
                p.vy *= 0.95;
                p.lifetime -= dt;
            }
            particles = particles.filter(p => p.lifetime > 0);
        }

        function checkCollisions() {
            if (!player.alive) return;

            // Player vs enemy projectiles
            for (const proj of projectiles) {
                if (proj.isPlayer) continue;
                if (player.collidesWith(proj) && player.invincibilityTimer <= 0) {
                    player.health -= proj.damage;
                    proj.alive = false;
                    player.invincibilityTimer = 0.5;

                    // Hit particles
                    for (let i = 0; i < 10; i++) {
                        particles.push(new Particle(
                            player.x, player.y,
                            (Math.random() - 0.5) * 200,
                            (Math.random() - 0.5) * 200,
                            '#ff0044',
                            2 + Math.random() * 2,
                            0.3
                        ));
                    }

                    if (player.health <= 0) {
                        player.alive = false;
                        gameOver();
                    }
                }
            }

            // Player vs enemies
            for (const enemy of enemies) {
                if (!enemy.alive) continue;
                if (player.collidesWith(enemy) && player.invincibilityTimer <= 0) {
                    player.health -= 10;
                    player.invincibilityTimer = 1;

                    // Knockback
                    const dx = player.x - enemy.x;
                    const dy = player.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    player.vx += (dx / dist) * 200;
                    player.vy += (dy / dist) * 200;

                    if (player.health <= 0) {
                        player.alive = false;
                        gameOver();
                    }
                }
            }

            // Player projectiles vs enemies
            for (const proj of projectiles) {
                if (!proj.isPlayer) continue;

                for (const enemy of enemies) {
                    if (!enemy.alive) continue;

                    if (proj.collidesWith(enemy)) {
                        enemy.health -= proj.damage;
                        proj.alive = false;

                        // Hit particles
                        for (let i = 0; i < 8; i++) {
                            particles.push(new Particle(
                                enemy.x, enemy.y,
                                (Math.random() - 0.5) * 150,
                                (Math.random() - 0.5) * 150,
                                enemy.color,
                                2 + Math.random() * 2,
                                0.3
                            ));
                        }

                        if (enemy.health <= 0) {
                            enemy.alive = false;
                            gameState.enemiesKilled++;
                            player.score += 100 * gameState.wave;
                            player.combo++;

                            // Death explosion
                            for (let i = 0; i < 20; i++) {
                                particles.push(new Particle(
                                    enemy.x, enemy.y,
                                    (Math.random() - 0.5) * 300,
                                    (Math.random() - 0.5) * 300,
                                    enemy.color,
                                    3 + Math.random() * 4,
                                    0.5
                                ));
                            }
                        }
                        break;
                    }
                }
            }

            enemies = enemies.filter(e => e.alive);
        }

        function updateWave() {
            const enemiesThisWave = CONSTANTS.ENEMIES_PER_WAVE_BASE + gameState.wave * 2;

            // Spawn enemies
            if (enemies.length < Math.min(8, 3 + gameState.wave)) {
                if (gameState.frame % Math.max(30, 90 - gameState.wave * 5) === 0) {
                    if (gameState.enemiesKilled + enemies.length < enemiesThisWave) {
                        spawnEnemy();
                    }
                }
            }

            // Wave complete?
            if (gameState.enemiesKilled >= enemiesThisWave && enemies.length === 0) {
                gameState.wave++;
                gameState.enemiesKilled = 0;
                player.score += 500 * gameState.wave;
                player.gravityBombs = Math.min(5, player.gravityBombs + 1);
                player.invincibilityTimer = 2;
                announceWave(gameState.wave);
            }
        }

        function recordState() {
            const stateStr = `${gameState.frame}:${Math.floor(player.x)}:${Math.floor(player.y)}:${player.score}:${gameState.wave}`;
            let hash = 0;
            for (let i = 0; i < stateStr.length; i++) {
                hash = ((hash << 5) - hash) + stateStr.charCodeAt(i);
                hash = hash & hash;
            }
            const hashStr = Math.abs(hash).toString(16).toUpperCase().slice(0, 8);
            gameState.stateHashes.push(hashStr);
            document.getElementById('stateHash').textContent = `Hash: ${hashStr}`;
        }

        function announceWave(wave) {
            const el = document.getElementById('waveAnnounce');
            el.textContent = `WAVE ${wave}`;
            el.classList.add('visible');
            setTimeout(() => el.classList.remove('visible'), 2000);
        }

        function gameOver() {
            gameState.running = false;
            document.getElementById('finalScore').textContent = player.score;
            document.getElementById('wavesCleared').textContent = `Waves cleared: ${gameState.wave - 1}`;
            document.getElementById('gameOver').style.display = 'block';
        }

        function restartGame() {
            initGame();
        }

        // ═══════════════════════════════════════════════════════════════════════
        // RENDERING
        // ═══════════════════════════════════════════════════════════════════════

        function render() {
            // Clear
            ctx.fillStyle = '#0f0f1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid
            ctx.strokeStyle = '#1a1a2a';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 40) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += 40) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Gravity wells
            for (const well of gravityWells) {
                const remaining = well.duration - (gameState.time - well.createdAt);
                const alpha = remaining / well.duration;

                // Outer glow
                const gradient = ctx.createRadialGradient(
                    well.x, well.y, 0,
                    well.x, well.y, well.radius
                );
                gradient.addColorStop(0, `rgba(0, 170, 255, ${alpha * 0.3})`);
                gradient.addColorStop(0.5, `rgba(0, 170, 255, ${alpha * 0.1})`);
                gradient.addColorStop(1, 'rgba(0, 170, 255, 0)');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(well.x, well.y, well.radius, 0, Math.PI * 2);
                ctx.fill();

                // Swirl effect
                ctx.strokeStyle = `rgba(0, 170, 255, ${alpha * 0.5})`;
                ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    const angle = (gameState.time * 2 + i * 2.1) % (Math.PI * 2);
                    const r = well.radius * 0.5 + Math.sin(gameState.time * 3 + i) * 20;
                    ctx.beginPath();
                    ctx.arc(well.x, well.y, r, angle, angle + 1);
                    ctx.stroke();
                }
            }

            // Particles
            for (const p of particles) {
                const alpha = p.lifetime / p.maxLifetime;
                ctx.fillStyle = p.color;
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // Projectiles
            for (const proj of projectiles) {
                ctx.fillStyle = proj.isPlayer ? '#00ff88' : '#ff4400';
                ctx.shadowBlur = 10;
                ctx.shadowColor = proj.isPlayer ? '#00ff88' : '#ff4400';
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, proj.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.shadowBlur = 0;

            // Enemies
            for (const enemy of enemies) {
                // Health bar
                const barWidth = enemy.size * 1.5;
                const barHeight = 4;
                const healthPercent = enemy.health / enemy.maxHealth;

                ctx.fillStyle = '#333';
                ctx.fillRect(enemy.x - barWidth/2, enemy.y - enemy.size - 10, barWidth, barHeight);
                ctx.fillStyle = enemy.color;
                ctx.fillRect(enemy.x - barWidth/2, enemy.y - enemy.size - 10, barWidth * healthPercent, barHeight);

                // Body
                ctx.fillStyle = enemy.color;
                ctx.shadowBlur = 15;
                ctx.shadowColor = enemy.color;
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.size / 2, 0, Math.PI * 2);
                ctx.fill();

                // Eye
                const eyeX = enemy.x + (player ? (player.x - enemy.x) : 0) * 0.1;
                const eyeY = enemy.y + (player ? (player.y - enemy.y) : 0) * 0.1;
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(eyeX, eyeY, 4, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.shadowBlur = 0;

            // Player
            if (player && player.alive) {
                // Invincibility flash
                if (player.invincibilityTimer > 0 && Math.floor(player.invincibilityTimer * 10) % 2 === 0) {
                    ctx.globalAlpha = 0.5;
                }

                // Glow
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#00ff88';

                // Body
                ctx.fillStyle = '#00ff88';
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.size / 2, 0, Math.PI * 2);
                ctx.fill();

                // Direction indicator (aim line)
                const aimDx = mouse.x - player.x;
                const aimDy = mouse.y - player.y;
                const aimDist = Math.sqrt(aimDx * aimDx + aimDy * aimDy) || 1;
                const aimX = player.x + (aimDx / aimDist) * 30;
                const aimY = player.y + (aimDy / aimDist) * 30;

                ctx.strokeStyle = '#00ff88';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(player.x, player.y);
                ctx.lineTo(aimX, aimY);
                ctx.stroke();

                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }

            // Update HUD
            if (player) {
                document.getElementById('healthBar').style.width = `${(player.health / player.maxHealth) * 100}%`;
                document.getElementById('scoreValue').textContent = player.score;
                document.getElementById('waveValue').textContent = gameState.wave;
                document.getElementById('bombsValue').textContent = player.gravityBombs;
            }
        }

        // ═══════════════════════════════════════════════════════════════════════
        // GAME LOOP
        // ═══════════════════════════════════════════════════════════════════════

        let lastTime = 0;

        function gameLoop(timestamp) {
            const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
            lastTime = timestamp;

            if (gameState.running) {
                gameState.time += dt;
                gameState.frame++;

                updatePlayer(dt);
                updateEnemies(dt);
                updateProjectiles(dt);
                updateGravityWells(dt);
                updateParticles(dt);
                checkCollisions();
                updateWave();

                // Record state every 60 frames
                if (gameState.frame % 60 === 0) {
                    recordState();
                }
            }

            render();
            requestAnimationFrame(gameLoop);
        }

        // ═══════════════════════════════════════════════════════════════════════
        // INPUT HANDLING
        // ═══════════════════════════════════════════════════════════════════════

        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;

            if (e.key === ' ' && gameState.running && player && player.alive) {
                e.preventDefault();
                createGravityWell(mouse.x, mouse.y);
            }

            if (e.key.toLowerCase() === 'r') {
                restartGame();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        });

        canvas.addEventListener('mousedown', () => {
            mouse.down = true;
        });

        canvas.addEventListener('mouseup', () => {
            mouse.down = false;
        });

        canvas.addEventListener('mouseleave', () => {
            mouse.down = false;
        });

        // Prevent context menu
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // ═══════════════════════════════════════════════════════════════════════
        // START GAME
        // ═══════════════════════════════════════════════════════════════════════

        initGame();
        requestAnimationFrame(gameLoop);

        console.log('Gravity Wars initialized');
        console.log('Constants Hash:', getConstantsHash());
        console.log('Newton Constraint Engine: Active');
    </script>
</body>
</html>
