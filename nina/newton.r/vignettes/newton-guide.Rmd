---
title: "Newton R Package: Constraint Verification Guide"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Newton R Package: Constraint Verification Guide}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Newton: Combinations Over Permutations

Newton is a constraint verification supercomputer that inverts traditional computing.
Instead of checking correctness after execution, **verification IS the execution**.

This guide covers the philosophy and practical usage of the Newton R package.

## The Core Philosophy

Traditional programming says: "If condition is true, do this."

Newton says: **"This state CANNOT exist."**

This is the "No-First" philosophy. We define boundaries (combinations) rather than
enumerate all valid paths (permutations).

### Why Combinations Over Permutations?

Consider validating a bank transaction:

**Permutation approach** (traditional):
```r
# Check every possible thing that could go wrong
if (amount > 0 &&
    amount <= balance &&
    account_active &&
    not_frozen &&
    daily_limit_ok &&
    ...) {
  # proceed
}
```

**Combination approach** (Newton):
```r
# Define the constraint space
BankAccount <- Blueprint(
  fields = list(balance = Money(0)),
  laws = list(
    no_overdraft = function(self) {
      when_cond(self$balance < Money(0), finfr())
    }
  )
)
```

The constraint space is the **combination** of all valid states.
Objects either fall within this space or they don't.
We don't enumerate every invalid input - we define the valid region.

## Installation

```r
# Install from source
devtools::install_local("path/to/newton.r")

# Or install dependencies manually
install.packages(c("httr2", "jsonlite", "R6"))
```

## Quick Start

### Local Verification with tinyTalk

```{r, eval=FALSE}
library(newton)

# Create a Blueprint with laws
Account <- Blueprint(
  fields = list(
    balance = Money(1000),
    owner = "Alice"
  ),
  laws = list(
    no_overdraft = function(self) {
      when_cond(self$balance < Money(0), finfr())
    }
  ),
  forges = list(
    withdraw = function(self, amount) {
      self$balance <- self$balance - amount
      self$balance
    },
    deposit = function(self, amount) {
      self$balance <- self$balance + amount
      self$balance
    }
  )
)

# Create instance
acct <- Account$new()
print(acct)  # Blueprint(balance=1000 USD, owner=Alice)

# Valid withdrawal
acct$withdraw(Money(500))  # Works! balance = 500

# Invalid withdrawal - triggers finfr
tryCatch(
  acct$withdraw(Money(600)),  # Would make balance = -100
  finfr = function(e) {
    cat("Blocked:", e$message, "\n")
  }
)
# Balance is still 500 (state was rolled back)
```

### Remote Verification with Newton API

```{r, eval=FALSE}
library(newton)

# Connect to Newton server
client <- Newton$new("http://localhost:8000", api_key = "your-key")

# Health check
client$health()

# Verify content safety
result <- client$verify("Hello world", categories = c("harm", "medical"))
result$verified  # TRUE

# Verified calculation
result <- client$calculate("sqrt(16) + 2^3")
result$result  # 12

# CDL constraint evaluation
result <- client$constraint(
  constraint = list(field = "balance", operator = "ge", value = 0),
  object = list(balance = 100)
)
result$verified  # TRUE
```

## The Four Books

### Book I: The Lexicon

The core words of constraint programming:

```{r, eval=FALSE}
# finfr() - Ontological Death
# The state CANNOT exist. Execution halts, state rolls back.
when_cond(balance < 0, finfr())

# fin() - Soft Closure
# The path is closed, but can be reopened.
when_cond(market_closed, fin())

# when_cond(condition, result)
# If condition is TRUE, execute result.
when_cond(leverage > 3, finfr())

# ratio(f, g, threshold)
# Every constraint is fundamentally f/g.
ratio(withdrawal, balance, threshold = 1.0)  # Cannot exceed 100%
```

### Book II: Matter Types

Prevent unit confusion (the Mars Climate Orbiter problem):

```{r, eval=FALSE}
# Create typed values
balance <- Money(1000, "USD")
weight <- Mass(75, "kg")
dist <- Distance(100, "m")

# Type-safe operations
total <- Money(500) + Money(300)  # Works
total <- Money(500) + Mass(10)    # ERROR: Cannot add Money and Mass

# Same-type division yields dimensionless ratio
ratio_val <- Money(500) / Money(1000)  # 0.5 (dimensionless)
```

Available Matter types:
- `Money(value, unit)` - Currency
- `Mass(value, unit)` - Weight/mass
- `Distance(value, unit)` - Length
- `Temperature(value, unit)` - Temperature
- `Pressure(value, unit)` - Pressure
- `Volume(value, unit)` - Volume
- `Time(value, unit)` - Duration
- `Ratio(value)` - Dimensionless ratio

### Book III: Blueprints

The pattern for constraint-verified state:

```{r, eval=FALSE}
# Define a Blueprint
TradingAccount <- Blueprint(
  # Fields: The state space
  fields = list(
    equity = Money(100000),
    debt = Money(0),
    positions = list()
  ),

  # Laws: What CANNOT happen
  laws = list(
    # Leverage cannot exceed 3x
    leverage_limit = function(self) {
      if (self$equity > Money(0)) {
        leverage <- self$debt$value / self$equity$value
        when_cond(leverage > 3.0, finfr())
      }
    },
    # Equity cannot go negative
    positive_equity = function(self) {
      when_cond(self$equity < Money(0), finfr())
    }
  ),

  # Forges: Operations under law protection
  forges = list(
    borrow = function(self, amount) {
      self$debt <- self$debt + amount
      sprintf("Borrowed %s, total debt: %s", amount$value, self$debt$value)
    },
    repay = function(self, amount) {
      self$debt <- self$debt - amount
      sprintf("Repaid %s, total debt: %s", amount$value, self$debt$value)
    }
  )
)

# Every forge execution:
# 1. Saves current state
# 2. Executes operation
# 3. Checks ALL laws
# 4. If any law triggers finfr -> rollback
# 5. If all laws pass -> commit
```

### Book IV: The Engine

Track motion through state space:

```{r, eval=FALSE}
# Capture state snapshots
p1 <- Presence(list(balance = 1000, count = 5), label = "before")
p2 <- Presence(list(balance = 800, count = 6), label = "after")

# Calculate what changed
delta <- calculate_delta(p1, p2)
print(delta)
# Delta(
#   balance: 1000 -> 800 (delta: -200)
#   count: 5 -> 6 (delta: +1)
# )

# Use KineticEngine for boundary enforcement
engine <- KineticEngine()

# Add boundary: balance cannot go negative
engine$add_boundary(
  function(delta) {
    if ("balance" %in% names(delta$changes)) {
      delta$changes$balance$to < 0
    } else {
      FALSE
    }
  },
  name = "no_overdraft"
)

# Test motion
result <- engine$resolve_motion(
  Presence(list(balance = 100)),
  Presence(list(balance = -50))
)
result$status  # "finfr" - boundary violated
```

## CDL Constraints

Build constraints for the Newton API:

```{r, eval=FALSE}
# Simple constraint
c1 <- constraint("balance", "ge", 0)

# Ratio constraint (f/g analysis)
c2 <- ratio_constraint("debt", "equity", "le", 3.0)

# Temporal constraint
c3 <- temporal_constraint("created_at", "within", "24h")

# Composite constraints
c4 <- all_of(
  constraint("age", "ge", 18),
  constraint("verified", "eq", TRUE)
)

c5 <- any_of(
  constraint("role", "eq", "admin"),
  constraint("role", "eq", "moderator")
)

# Domain-specific builders
no_od <- financial$no_overdraft("balance")
lev <- financial$leverage_limit("debt", "equity", 3.0)
```

## The f/g Ratio

Every constraint in Newton is fundamentally a ratio:

- **f** = what you're trying to do (forge/fact/function)
- **g** = what reality allows (ground/goal/governance)

```{r, eval=FALSE}
# Withdrawal / Balance <= 1.0
# f = withdrawal amount
# g = available balance
ratio(withdrawal, balance, threshold = 1.0)

# Debt / Equity <= 3.0 (leverage limit)
# f = debt taken
# g = equity available
ratio(debt, equity, threshold = 3.0)

# When g = 0: finfr (division by zero = undefined constraint space)
# When f/g > threshold: finfr (exceeds bounds)
```

## Complete Example: Risk-Governed Trading

```{r, eval=FALSE}
library(newton)

# Define a risk-governed trading system
TradingSystem <- Blueprint(
  fields = list(
    capital = Money(1000000),
    exposure = Money(0),
    trades_today = 0,
    max_daily_trades = 100
  ),

  laws = list(
    # Cannot exceed 10x leverage
    max_leverage = function(self) {
      if (self$capital > Money(0)) {
        leverage <- self$exposure$value / self$capital$value
        when_cond(leverage > 10, finfr())
      }
    },

    # Cannot exceed daily trade limit
    trade_limit = function(self) {
      when_cond(self$trades_today > self$max_daily_trades, finfr())
    },

    # Exposure cannot be negative
    positive_exposure = function(self) {
      when_cond(self$exposure < Money(0), finfr())
    }
  ),

  forges = list(
    open_position = function(self, size) {
      self$exposure <- self$exposure + size
      self$trades_today <- self$trades_today + 1
      list(
        status = "opened",
        exposure = self$exposure$value,
        trades = self$trades_today
      )
    },

    close_position = function(self, size) {
      self$exposure <- self$exposure - size
      self$trades_today <- self$trades_today + 1
      list(
        status = "closed",
        exposure = self$exposure$value,
        trades = self$trades_today
      )
    }
  )
)

# Create and use
system <- TradingSystem$new()

# Valid operations
system$open_position(Money(5000000))  # 5x leverage - OK
system$open_position(Money(4000000))  # 9x leverage - OK

# This would exceed 10x - blocked by finfr
tryCatch(
  system$open_position(Money(2000000)),  # Would be 11x
  finfr = function(e) cat("RISK LIMIT:", e$message, "\n")
)

# State unchanged - still at 9x leverage
print(system)
```

## Trajectory Analysis

Track the path through state space:

```{r, eval=FALSE}
traj <- Trajectory()

# Record states over time
traj$record(list(balance = 1000, risk = 0.1), label = "start")
traj$record(list(balance = 1200, risk = 0.15), label = "growth")
traj$record(list(balance = 1100, risk = 0.12), label = "correction")
traj$record(list(balance = 1500, risk = 0.18), label = "end")

# Analyze
traj$summary()
# Trajectory: 4 presences, 3 deltas
# First state: Presence(balance=1000, risk=0.1)
# Last state: Presence(balance=1500, risk=0.18)
# Total motion:
#   balance: 1000 -> 1500 (delta: +500)
#   risk: 0.1 -> 0.18 (delta: +0.08)
```

## Visualization Ideas

Use R's plotting capabilities to visualize constraint spaces:

```{r, eval=FALSE}
library(ggplot2)

# Visualize a 2D constraint space
# Example: balance vs exposure with leverage constraint

# Generate grid of possible states
grid <- expand.grid(
  balance = seq(100, 10000, by = 100),
  exposure = seq(0, 50000, by = 500)
)

# Apply constraint: leverage <= 3
grid$valid <- with(grid, exposure / balance <= 3)

# Plot
ggplot(grid, aes(x = balance, y = exposure, fill = valid)) +
  geom_tile() +
  scale_fill_manual(values = c("TRUE" = "green", "FALSE" = "red")) +
  labs(
    title = "Constraint Space: 3x Leverage Limit",
    subtitle = "Green = valid states, Red = finfr",
    x = "Balance",
    y = "Exposure"
  ) +
  theme_minimal()
```

## Summary

Newton's R package provides:

1. **tinyTalk Language** - The "No-First" constraint language
2. **Matter Types** - Type-safe values preventing unit confusion
3. **Blueprints** - State + Laws + Forges pattern
4. **KineticEngine** - Motion and boundary enforcement
5. **CDL Builders** - Constraint Definition Language helpers
6. **Newton Client** - HTTP interface to Newton API

The key insight: **Combinations over permutations**.

Define the valid constraint space. Objects either satisfy constraints or they don't.
No need to enumerate all invalid inputs - just define the boundaries.

```
newton(current, goal) = current == goal

finfr = f/g  (when g=0 or f/g exceeds threshold: ontological death)
```

This is verification AS computation, not verification OF computation.
