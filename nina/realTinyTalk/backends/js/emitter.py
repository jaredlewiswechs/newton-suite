"""
═══════════════════════════════════════════════════════════════════════════════
realTinyTalk → JavaScript BACKEND
═══════════════════════════════════════════════════════════════════════════════

Transpiles realTinyTalk AST to readable JavaScript.

Design Principles:
1. Emit READABLE JS, not clever JS
2. Use runtime helpers for tinyTalk-specific features
3. Keep 1:1 mapping where possible
4. Preserve source structure for debugging

Mapping:
  let x = 42           →  let x = 42;
  when PI = 3.14       →  const PI = 3.14;
  law f(x) ... end     →  function f(x) { ... }
  forge g() ... end    →  function g() { ... }
  if/elif/else         →  if/else if/else
  for i in range(n)    →  for (let i = 0; i < n; i++)
  while cond           →  while (cond)
  show(...)            →  tt.show(...)
  x is y               →  tt.is(x, y)
  x has .f             →  tt.has(x, "f")
  x _sort _filter(fn)  →  tt.chain(x).sort().filter(fn).value()
  blueprint B { }      →  class B { }
"""

import sys
from pathlib import Path
from typing import List, Optional, Any
from dataclasses import dataclass

# Add parent to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent.parent.parent))

from realTinyTalk.parser import (
    Program, ASTNode, NodeType,
    Literal, Identifier, BinaryOp, UnaryOp, Call, Index, Member,
    Array, MapLiteral, Lambda, Conditional, Range, Pipe, StepChain,
    LetStmt, ConstStmt, AssignStmt, Block, IfStmt, ForStmt, WhileStmt,
    ReturnStmt, BreakStmt, ContinueStmt, FnDecl, StructDecl, ImportStmt
)


# ═══════════════════════════════════════════════════════════════════════════════
# JS EMITTER
# ═══════════════════════════════════════════════════════════════════════════════

class JSEmitter:
    """
    Transpiles realTinyTalk AST to JavaScript source code.
    """
    
    def __init__(self, include_runtime: bool = True, indent_size: int = 2):
        self.include_runtime = include_runtime
        self.indent_size = indent_size
        self.indent_level = 0
        self.output_lines: List[str] = []
    
    def emit(self, ast: Program) -> str:
        """Emit JavaScript from AST."""
        self.output_lines = []
        self.indent_level = 0
        
        # Emit runtime header if requested
        if self.include_runtime:
            self._emit_runtime_header()
        
        # Emit each statement
        for stmt in ast.statements:
            js = self._emit_node(stmt)
            if js:
                self._write(js)
        
        return '\n'.join(self.output_lines)
    
    # ─────────────────────────────────────────────────────────────────────────
    # OUTPUT HELPERS
    # ─────────────────────────────────────────────────────────────────────────
    
    def _indent(self) -> str:
        return ' ' * (self.indent_level * self.indent_size)
    
    def _write(self, line: str):
        """Write a line with current indentation."""
        if line.strip():
            self.output_lines.append(self._indent() + line)
        else:
            self.output_lines.append('')
    
    def _write_raw(self, line: str):
        """Write without indentation."""
        self.output_lines.append(line)
    
    # ─────────────────────────────────────────────────────────────────────────
    # RUNTIME HEADER
    # ─────────────────────────────────────────────────────────────────────────
    
    def _emit_runtime_header(self):
        """Emit the tinyTalk runtime shim."""
        self._write_raw("// ═══════════════════════════════════════════════════════════════")
        self._write_raw("// Generated by realTinyTalk → JavaScript transpiler")
        self._write_raw("// ═══════════════════════════════════════════════════════════════")
        self._write_raw("")
        self._write_raw("const tt = {")
        self._write_raw("  // Core I/O")
        self._write_raw("  show: (...args) => console.log(args.map(tt.str).join(' ')),")
        self._write_raw("  ")
        self._write_raw("  // Type conversion")
        self._write_raw("  str: (x) => x === null ? 'null' : x === undefined ? 'null' : String(x),")
        self._write_raw("  int: (x) => parseInt(x, 10) || 0,")
        self._write_raw("  float: (x) => parseFloat(x) || 0.0,")
        self._write_raw("  bool: (x) => !!x,")
        self._write_raw("  ")
        self._write_raw("  // Type checking")
        self._write_raw("  typeof: (x) => {")
        self._write_raw("    if (x === null || x === undefined) return 'null';")
        self._write_raw("    if (Array.isArray(x)) return 'list';")
        self._write_raw("    if (typeof x === 'object') return 'map';")
        self._write_raw("    return typeof x;")
        self._write_raw("  },")
        self._write_raw("  ")
        self._write_raw("  // Natural comparisons (is, isnt, has, isin)")
        self._write_raw("  is: (a, b) => {")
        self._write_raw("    if (Array.isArray(a) && Array.isArray(b)) {")
        self._write_raw("      return a.length === b.length && a.every((v, i) => tt.is(v, b[i]));")
        self._write_raw("    }")
        self._write_raw("    return a === b;")
        self._write_raw("  },")
        self._write_raw("  isnt: (a, b) => !tt.is(a, b),")
        self._write_raw("  has: (obj, item) => {")
        self._write_raw("    if (obj == null) return false;")
        self._write_raw("    if (Array.isArray(obj)) return obj.includes(item);")
        self._write_raw("    if (typeof obj === 'string') return obj.includes(item);")
        self._write_raw("    if (typeof obj === 'object') return item in obj;")
        self._write_raw("    return false;")
        self._write_raw("  },")
        self._write_raw("  hasnt: (obj, field) => !tt.has(obj, field),")
        self._write_raw("  isin: (item, collection) => {")
        self._write_raw("    if (Array.isArray(collection)) return collection.includes(item);")
        self._write_raw("    if (typeof collection === 'string') return collection.includes(item);")
        self._write_raw("    if (typeof collection === 'object') return item in collection;")
        self._write_raw("    return false;")
        self._write_raw("  },")
        self._write_raw("  islike: (str, pattern) => {")
        self._write_raw("    // Convert glob pattern to regex")
        self._write_raw("    const regex = pattern.replace(/[.+^${}()|[\\]\\\\]/g, '\\\\$&')")
        self._write_raw("                          .replace(/\\*/g, '.*')")
        self._write_raw("                          .replace(/\\?/g, '.');")
        self._write_raw("    return new RegExp('^' + regex + '$').test(String(str));")
        self._write_raw("  },")
        self._write_raw("  ")
        self._write_raw("  // Collection helpers")
        self._write_raw("  len: (x) => {")
        self._write_raw("    if (x == null) return 0;")
        self._write_raw("    if (Array.isArray(x) || typeof x === 'string') return x.length;")
        self._write_raw("    if (typeof x === 'object') return Object.keys(x).length;")
        self._write_raw("    return 0;")
        self._write_raw("  },")
        self._write_raw("  keys: (x) => x == null ? [] : Object.keys(x),")
        self._write_raw("  values: (x) => x == null ? [] : Object.values(x),")
        self._write_raw("  ")
        self._write_raw("  // Range generator")
        self._write_raw("  range: (start, end, step = 1) => {")
        self._write_raw("    if (end === undefined) { end = start; start = 0; }")
        self._write_raw("    const result = [];")
        self._write_raw("    for (let i = start; step > 0 ? i < end : i > end; i += step) {")
        self._write_raw("      result.push(i);")
        self._write_raw("    }")
        self._write_raw("    return result;")
        self._write_raw("  },")
        self._write_raw("  ")
        self._write_raw("  // Math")
        self._write_raw("  abs: Math.abs,")
        self._write_raw("  floor: Math.floor,")
        self._write_raw("  ceil: Math.ceil,")
        self._write_raw("  round: (x, n = 0) => {")
        self._write_raw("    const f = Math.pow(10, n);")
        self._write_raw("    return Math.round(x * f) / f;")
        self._write_raw("  },")
        self._write_raw("  min: (...args) => args.length === 1 && Array.isArray(args[0]) ? Math.min(...args[0]) : Math.min(...args),")
        self._write_raw("  max: (...args) => args.length === 1 && Array.isArray(args[0]) ? Math.max(...args[0]) : Math.max(...args),")
        self._write_raw("  sum: (arr) => arr.reduce((a, b) => a + b, 0),")
        self._write_raw("  avg: (arr) => arr.length ? tt.sum(arr) / arr.length : 0,")
        self._write_raw("  ")
        self._write_raw("  // List operations")
        self._write_raw("  push: (arr, item) => { arr.push(item); return arr; },")
        self._write_raw("  pop: (arr) => arr.pop(),")
        self._write_raw("  append: (arr, item) => [...arr, item],")
        self._write_raw("  concat: (a, b) => [...a, ...b],")
        self._write_raw("  slice: (arr, start, end) => arr.slice(start, end),")
        self._write_raw("  join: (arr, sep = '') => arr.join(sep),")
        self._write_raw("  split: (str, sep) => str.split(sep),")
        self._write_raw("  ")
        self._write_raw("  // String properties")
        self._write_raw("  upcase: (s) => String(s).toUpperCase(),")
        self._write_raw("  lowcase: (s) => String(s).toLowerCase(),")
        self._write_raw("  trim: (s) => String(s).trim(),")
        self._write_raw("  chars: (s) => String(s).split(''),")
        self._write_raw("  words: (s) => String(s).split(/\\s+/).filter(w => w),")
        self._write_raw("  ")
        self._write_raw("  // Property magic dispatcher")
        self._write_raw("  prop: (obj, name) => {")
        self._write_raw("    // String properties")
        self._write_raw("    if (typeof obj === 'string') {")
        self._write_raw("      switch (name) {")
        self._write_raw("        case 'len': case 'length': return obj.length;")
        self._write_raw("        case 'upcase': return obj.toUpperCase();")
        self._write_raw("        case 'lowcase': return obj.toLowerCase();")
        self._write_raw("        case 'trim': return obj.trim();")
        self._write_raw("        case 'chars': return obj.split('');")
        self._write_raw("        case 'words': return obj.split(/\\s+/).filter(w => w);")
        self._write_raw("        case 'first': return obj[0] || '';")
        self._write_raw("        case 'last': return obj[obj.length - 1] || '';")
        self._write_raw("        case 'reversed': return obj.split('').reverse().join('');")
        self._write_raw("        case 'int': return parseInt(obj, 10) || 0;")
        self._write_raw("        case 'float': return parseFloat(obj) || 0;")
        self._write_raw("        case 'str': return obj;")
        self._write_raw("      }")
        self._write_raw("    }")
        self._write_raw("    // Array properties")
        self._write_raw("    if (Array.isArray(obj)) {")
        self._write_raw("      switch (name) {")
        self._write_raw("        case 'len': case 'length': return obj.length;")
        self._write_raw("        case 'first': return obj[0];")
        self._write_raw("        case 'last': return obj[obj.length - 1];")
        self._write_raw("        case 'rest': return obj.slice(1);")
        self._write_raw("        case 'sum': return obj.reduce((a, b) => a + b, 0);")
        self._write_raw("        case 'avg': return obj.length ? obj.reduce((a, b) => a + b, 0) / obj.length : 0;")
        self._write_raw("        case 'min': return Math.min(...obj);")
        self._write_raw("        case 'max': return Math.max(...obj);")
        self._write_raw("        case 'sorted': case 'sort': return [...obj].sort((a, b) => a - b);")
        self._write_raw("        case 'reversed': return [...obj].reverse();")
        self._write_raw("        case 'uniq': return [...new Set(obj)];")
        self._write_raw("        case 'empty': return obj.length === 0;")
        self._write_raw("        case 'any': return obj.length > 0;")
        self._write_raw("        case 'str': return JSON.stringify(obj);")
        self._write_raw("      }")
        self._write_raw("    }")
        self._write_raw("    // Object properties")
        self._write_raw("    if (obj && typeof obj === 'object') {")
        self._write_raw("      switch (name) {")
        self._write_raw("        case 'keys': return Object.keys(obj);")
        self._write_raw("        case 'vals': case 'values': return Object.values(obj);")
        self._write_raw("        case 'len': case 'length': return Object.keys(obj).length;")
        self._write_raw("        case 'empty': return Object.keys(obj).length === 0;")
        self._write_raw("        case 'str': return JSON.stringify(obj);")
        self._write_raw("      }")
        self._write_raw("      // Direct field access")
        self._write_raw("      if (name in obj) return obj[name];")
        self._write_raw("    }")
        self._write_raw("    // Type properties")
        self._write_raw("    switch (name) {")
        self._write_raw("      case 'type': return tt.typeof(obj);")
        self._write_raw("      case 'str': return tt.str(obj);")
        self._write_raw("      case 'int': return tt.int(obj);")
        self._write_raw("      case 'float': return tt.float(obj);")
        self._write_raw("      case 'bool': return tt.bool(obj);")
        self._write_raw("    }")
        self._write_raw("    return undefined;")
        self._write_raw("  },")
        self._write_raw("  ")
        self._write_raw("  // Step chain builder")
        self._write_raw("  chain: (data) => ({")
        self._write_raw("    _data: Array.isArray(data) ? data : [data],")
        self._write_raw("    sort(fn) { this._data = [...this._data].sort(fn || ((a, b) => a - b)); return this; },")
        self._write_raw("    sortdown(fn) { this._data = [...this._data].sort(fn || ((a, b) => b - a)); return this; },")
        self._write_raw("    filter(fn) { this._data = this._data.filter(fn); return this; },")
        self._write_raw("    reject(fn) { this._data = this._data.filter(x => !fn(x)); return this; },")
        self._write_raw("    map(fn) { this._data = this._data.map(fn); return this; },")
        self._write_raw("    each(fn) { this._data.forEach(fn); return this; },")
        self._write_raw("    take(n) { this._data = this._data.slice(0, n); return this; },")
        self._write_raw("    skip(n) { this._data = this._data.slice(n); return this; },")
        self._write_raw("    first() { return this._data[0]; },")
        self._write_raw("    last() { return this._data[this._data.length - 1]; },")
        self._write_raw("    sum() { return this._data.reduce((a, b) => a + b, 0); },")
        self._write_raw("    avg() { return this._data.length ? this.sum() / this._data.length : 0; },")
        self._write_raw("    min() { return Math.min(...this._data); },")
        self._write_raw("    max() { return Math.max(...this._data); },")
        self._write_raw("    count() { return this._data.length; },")
        self._write_raw("    uniq() { this._data = [...new Set(this._data)]; return this; },")
        self._write_raw("    flat() { this._data = this._data.flat(); return this; },")
        self._write_raw("    reverse() { this._data = [...this._data].reverse(); return this; },")
        self._write_raw("    find(fn) { return this._data.find(fn); },")
        self._write_raw("    any(fn) { return fn ? this._data.some(fn) : this._data.length > 0; },")
        self._write_raw("    all(fn) { return fn ? this._data.every(fn) : this._data.every(x => !!x); },")
        self._write_raw("    none(fn) { return fn ? !this._data.some(fn) : this._data.length === 0; },")
        self._write_raw("    value() { return this._data; },")
        self._write_raw("  }),")
        self._write_raw("};")
        self._write_raw("")
        self._write_raw("// ═══════════════════════════════════════════════════════════════")
        self._write_raw("// User Code")
        self._write_raw("// ═══════════════════════════════════════════════════════════════")
        self._write_raw("")
    
    # ─────────────────────────────────────────────────────────────────────────
    # NODE DISPATCH
    # ─────────────────────────────────────────────────────────────────────────
    
    def _emit_node(self, node: ASTNode) -> str:
        """Dispatch to appropriate emitter based on node type."""
        if node is None:
            return ''
        
        handlers = {
            NodeType.LITERAL: self._emit_literal,
            NodeType.IDENTIFIER: self._emit_identifier,
            NodeType.BINARY_OP: self._emit_binary,
            NodeType.UNARY_OP: self._emit_unary,
            NodeType.CALL: self._emit_call,
            NodeType.INDEX: self._emit_index,
            NodeType.MEMBER: self._emit_member,
            NodeType.ARRAY: self._emit_array,
            NodeType.MAP_LITERAL: self._emit_map,
            NodeType.LAMBDA: self._emit_lambda,
            NodeType.CONDITIONAL: self._emit_conditional,
            NodeType.RANGE: self._emit_range,
            NodeType.PIPE: self._emit_pipe,
            NodeType.STEP_CHAIN: self._emit_step_chain,
            NodeType.LET_STMT: self._emit_let,
            NodeType.CONST_STMT: self._emit_const,
            NodeType.ASSIGN: self._emit_assign,
            NodeType.BLOCK_STMT: self._emit_block,
            NodeType.IF_STMT: self._emit_if,
            NodeType.FOR_STMT: self._emit_for,
            NodeType.WHILE_STMT: self._emit_while,
            NodeType.RETURN_STMT: self._emit_return,
            NodeType.BREAK_STMT: self._emit_break,
            NodeType.CONTINUE_STMT: self._emit_continue,
            NodeType.FN_DECL: self._emit_function,
            NodeType.STRUCT_DECL: self._emit_class,
            NodeType.IMPORT_STMT: self._emit_import,
        }
        
        handler = handlers.get(node.type)
        if handler:
            return handler(node)
        
        # Unknown node type - emit comment
        return f"/* TODO: {node.type.name} */"
    
    # ─────────────────────────────────────────────────────────────────────────
    # EXPRESSIONS
    # ─────────────────────────────────────────────────────────────────────────
    
    def _emit_literal(self, node: Literal) -> str:
        """Emit literal value."""
        if node.value is None:
            return 'null'
        if isinstance(node.value, bool):
            return 'true' if node.value else 'false'
        if isinstance(node.value, str):
            # Escape string properly
            escaped = node.value.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n')
            return f'"{escaped}"'
        return str(node.value)
    
    def _emit_identifier(self, node: Identifier) -> str:
        """Emit identifier."""
        # Map reserved words / builtins
        name = node.name
        
        # Self → this
        if name == 'self':
            return 'this'
        
        return name
    
    def _emit_binary(self, node: BinaryOp) -> str:
        """Emit binary operation."""
        left = self._emit_node(node.left)
        right = self._emit_node(node.right)
        op = node.op
        
        # Natural comparison operators → runtime helpers
        if op == 'is':
            return f'tt.is({left}, {right})'
        if op == 'isnt':
            return f'tt.isnt({left}, {right})'
        if op == 'has':
            return f'tt.has({left}, {right})'
        if op == 'hasnt':
            return f'tt.hasnt({left}, {right})'
        if op == 'isin':
            return f'tt.isin({left}, {right})'
        if op == 'islike':
            return f'tt.islike({left}, {right})'
        
        # Exponentiation
        if op == '**':
            return f'Math.pow({left}, {right})'
        
        # Standard ops
        js_ops = {
            'and': '&&',
            'or': '||',
            '==': '===',
            '!=': '!==',
        }
        js_op = js_ops.get(op, op)
        
        return f'({left} {js_op} {right})'
    
    def _emit_unary(self, node: UnaryOp) -> str:
        """Emit unary operation."""
        operand = self._emit_node(node.operand)
        op = node.op
        
        if op == 'not':
            return f'!{operand}'
        
        if node.prefix:
            return f'{op}{operand}'
        return f'{operand}{op}'
    
    def _emit_call(self, node: Call) -> str:
        """Emit function call."""
        args = ', '.join(self._emit_node(a) for a in node.args)
        
        # Check for builtin functions that need runtime
        if isinstance(node.callee, Identifier):
            name = node.callee.name
            
            # Map to runtime
            runtime_funcs = {
                'show', 'print', 'println',
                'len', 'typeof', 'str', 'int', 'float', 'bool',
                'range', 'abs', 'floor', 'ceil', 'round',
                'min', 'max', 'sum', 'avg',
                'push', 'pop', 'append', 'concat', 'slice', 'join', 'split',
                'keys', 'values', 'upcase', 'lowcase', 'trim', 'chars', 'words',
            }
            
            if name in runtime_funcs:
                return f'tt.{name}({args})'
        
        callee = self._emit_node(node.callee)
        return f'{callee}({args})'
    
    def _emit_index(self, node: Index) -> str:
        """Emit index access."""
        obj = self._emit_node(node.obj)
        index = self._emit_node(node.index)
        return f'{obj}[{index}]'
    
    def _emit_member(self, node: Member) -> str:
        """Emit member access."""
        obj = self._emit_node(node.obj)
        field = node.field
        
        # Property magic - use runtime helper
        magic_props = {
            'len', 'length', 'first', 'last', 'rest',
            'upcase', 'lowcase', 'trim', 'chars', 'words',
            'sum', 'avg', 'min', 'max', 'sorted', 'sort', 'reversed', 'uniq',
            'keys', 'vals', 'values', 'empty', 'any',
            'str', 'int', 'float', 'bool', 'type'
        }
        
        if field in magic_props:
            return f'tt.prop({obj}, "{field}")'
        
        return f'{obj}.{field}'
    
    def _emit_array(self, node: Array) -> str:
        """Emit array literal."""
        elements = ', '.join(self._emit_node(e) for e in node.elements)
        return f'[{elements}]'
    
    def _emit_map(self, node: MapLiteral) -> str:
        """Emit map/object literal."""
        pairs = []
        for key, value in node.pairs:
            k = self._emit_node(key)
            v = self._emit_node(value)
            # If key is a string literal, we can use it directly
            if isinstance(key, Literal) and isinstance(key.value, str):
                pairs.append(f'"{key.value}": {v}')
            else:
                pairs.append(f'[{k}]: {v}')
        return '{' + ', '.join(pairs) + '}'
    
    def _emit_lambda(self, node: Lambda) -> str:
        """Emit lambda/arrow function."""
        params = ', '.join(node.params)
        body = self._emit_node(node.body)
        
        if len(node.params) == 1:
            return f'{node.params[0]} => {body}'
        return f'({params}) => {body}'
    
    def _emit_conditional(self, node: Conditional) -> str:
        """Emit ternary conditional."""
        cond = self._emit_node(node.condition)
        then = self._emit_node(node.then_expr)
        else_ = self._emit_node(node.else_expr)
        return f'({cond} ? {then} : {else_})'
    
    def _emit_range(self, node: Range) -> str:
        """Emit range expression."""
        start = self._emit_node(node.start)
        end = self._emit_node(node.end)
        # Use runtime range helper
        return f'tt.range({start}, {end})'
    
    def _emit_pipe(self, node: Pipe) -> str:
        """Emit pipe expression."""
        left = self._emit_node(node.left)
        right = self._emit_node(node.right)
        # x |> f  →  f(x)
        return f'{right}({left})'
    
    def _emit_step_chain(self, node: StepChain) -> str:
        """Emit step chain (dplyr-style)."""
        source = self._emit_node(node.source)
        
        chain = f'tt.chain({source})'
        
        for step_name, args in node.steps:
            # Remove underscore prefix for JS
            method = step_name.lstrip('_')
            
            if args:
                arg_str = ', '.join(self._emit_node(a) for a in args)
                chain += f'.{method}({arg_str})'
            else:
                # Terminal steps (return value) vs chain steps (return chain)
                terminal_steps = {'first', 'last', 'sum', 'avg', 'min', 'max', 'count', 'find', 'any', 'all', 'none'}
                if method in terminal_steps:
                    chain += f'.{method}()'
                else:
                    chain += f'.{method}()'
        
        # Add .value() if chain ends with a non-terminal step
        last_step = node.steps[-1][0].lstrip('_') if node.steps else ''
        terminal_steps = {'first', 'last', 'sum', 'avg', 'min', 'max', 'count', 'find', 'any', 'all', 'none'}
        if last_step not in terminal_steps:
            chain += '.value()'
        
        return chain
    
    # ─────────────────────────────────────────────────────────────────────────
    # STATEMENTS
    # ─────────────────────────────────────────────────────────────────────────
    
    def _emit_let(self, node: LetStmt) -> str:
        """Emit let statement."""
        if node.value:
            value = self._emit_node(node.value)
            return f'let {node.name} = {value};'
        return f'let {node.name};'
    
    def _emit_const(self, node: ConstStmt) -> str:
        """Emit const statement."""
        value = self._emit_node(node.value)
        return f'const {node.name} = {value};'
    
    def _emit_assign(self, node: AssignStmt) -> str:
        """Emit assignment."""
        target = self._emit_node(node.target)
        value = self._emit_node(node.value)
        return f'{target} {node.op} {value};'
    
    def _emit_block(self, node: Block) -> str:
        """Emit block of statements."""
        lines = []
        lines.append('{')
        self.indent_level += 1
        for stmt in node.statements:
            js = self._emit_node(stmt)
            if js:
                lines.append(self._indent() + js)
        self.indent_level -= 1
        lines.append(self._indent() + '}')
        return '\n'.join(lines)
    
    def _emit_if(self, node: IfStmt) -> str:
        """Emit if statement."""
        lines = []
        
        cond = self._emit_node(node.condition)
        lines.append(f'if ({cond}) {{')
        
        self.indent_level += 1
        if isinstance(node.then_branch, Block):
            for stmt in node.then_branch.statements:
                js = self._emit_node(stmt)
                if js:
                    lines.append(self._indent() + js)
        else:
            js = self._emit_node(node.then_branch)
            if js:
                lines.append(self._indent() + js)
        self.indent_level -= 1
        
        # elif branches
        for elif_cond, elif_body in node.elif_branches:
            cond = self._emit_node(elif_cond)
            lines.append(self._indent() + f'}} else if ({cond}) {{')
            self.indent_level += 1
            if isinstance(elif_body, Block):
                for stmt in elif_body.statements:
                    js = self._emit_node(stmt)
                    if js:
                        lines.append(self._indent() + js)
            else:
                js = self._emit_node(elif_body)
                if js:
                    lines.append(self._indent() + js)
            self.indent_level -= 1
        
        # else branch
        if node.else_branch:
            lines.append(self._indent() + '} else {')
            self.indent_level += 1
            if isinstance(node.else_branch, Block):
                for stmt in node.else_branch.statements:
                    js = self._emit_node(stmt)
                    if js:
                        lines.append(self._indent() + js)
            else:
                js = self._emit_node(node.else_branch)
                if js:
                    lines.append(self._indent() + js)
            self.indent_level -= 1
        
        lines.append(self._indent() + '}')
        return '\n'.join(lines)
    
    def _emit_for(self, node: ForStmt) -> str:
        """Emit for loop."""
        lines = []
        var = node.var
        iterable = self._emit_node(node.iterable)
        
        # for i in range(n) → for (let i = 0; i < n; i++)
        # for x in list → for (const x of list)
        
        # Check if iterable is a range call
        if isinstance(node.iterable, Call) and isinstance(node.iterable.callee, Identifier):
            if node.iterable.callee.name == 'range':
                args = node.iterable.args
                if len(args) == 1:
                    end = self._emit_node(args[0])
                    lines.append(f'for (let {var} = 0; {var} < {end}; {var}++) {{')
                elif len(args) >= 2:
                    start = self._emit_node(args[0])
                    end = self._emit_node(args[1])
                    if len(args) >= 3:
                        step = self._emit_node(args[2])
                        lines.append(f'for (let {var} = {start}; {var} < {end}; {var} += {step}) {{')
                    else:
                        lines.append(f'for (let {var} = {start}; {var} < {end}; {var}++) {{')
            else:
                lines.append(f'for (const {var} of {iterable}) {{')
        else:
            lines.append(f'for (const {var} of {iterable}) {{')
        
        self.indent_level += 1
        if isinstance(node.body, Block):
            for stmt in node.body.statements:
                js = self._emit_node(stmt)
                if js:
                    lines.append(self._indent() + js)
        else:
            js = self._emit_node(node.body)
            if js:
                lines.append(self._indent() + js)
        self.indent_level -= 1
        
        lines.append(self._indent() + '}')
        return '\n'.join(lines)
    
    def _emit_while(self, node: WhileStmt) -> str:
        """Emit while loop."""
        lines = []
        cond = self._emit_node(node.condition)
        lines.append(f'while ({cond}) {{')
        
        self.indent_level += 1
        if isinstance(node.body, Block):
            for stmt in node.body.statements:
                js = self._emit_node(stmt)
                if js:
                    lines.append(self._indent() + js)
        else:
            js = self._emit_node(node.body)
            if js:
                lines.append(self._indent() + js)
        self.indent_level -= 1
        
        lines.append(self._indent() + '}')
        return '\n'.join(lines)
    
    def _emit_return(self, node: ReturnStmt) -> str:
        """Emit return statement."""
        if node.value:
            value = self._emit_node(node.value)
            return f'return {value};'
        return 'return;'
    
    def _emit_break(self, node: BreakStmt) -> str:
        return 'break;'
    
    def _emit_continue(self, node: ContinueStmt) -> str:
        return 'continue;'
    
    def _emit_function(self, node: FnDecl) -> str:
        """Emit function declaration."""
        lines = []
        
        params = ', '.join(p[0] if isinstance(p, tuple) else p for p in node.params)
        lines.append(f'function {node.name}({params}) {{')
        
        self.indent_level += 1
        if isinstance(node.body, Block):
            for stmt in node.body.statements:
                js = self._emit_node(stmt)
                if js:
                    lines.append(self._indent() + js)
        else:
            js = self._emit_node(node.body)
            if js:
                lines.append(self._indent() + js)
        self.indent_level -= 1
        
        lines.append(self._indent() + '}')
        return '\n'.join(lines)
    
    def _emit_class(self, node: StructDecl) -> str:
        """Emit class declaration (from blueprint)."""
        lines = []
        lines.append(f'class {node.name} {{')
        
        self.indent_level += 1
        
        # Constructor with fields
        if node.fields:
            params = ', '.join(f'{f[0]} = {self._emit_node(f[2]) if len(f) > 2 and f[2] else "null"}' 
                              for f in node.fields)
            lines.append(self._indent() + f'constructor({params}) {{')
            self.indent_level += 1
            for f in node.fields:
                name = f[0]
                lines.append(self._indent() + f'this.{name} = {name};')
            self.indent_level -= 1
            lines.append(self._indent() + '}')
        else:
            lines.append(self._indent() + 'constructor() {}')
        
        # Methods
        for method_type, fn in node.methods:
            params = ', '.join(p[0] if isinstance(p, tuple) else p for p in fn.params)
            lines.append(self._indent() + f'{fn.name}({params}) {{')
            self.indent_level += 1
            if isinstance(fn.body, Block):
                for stmt in fn.body.statements:
                    js = self._emit_node(stmt)
                    if js:
                        lines.append(self._indent() + js)
            else:
                js = self._emit_node(fn.body)
                if js:
                    lines.append(self._indent() + js)
            self.indent_level -= 1
            lines.append(self._indent() + '}')
        
        self.indent_level -= 1
        lines.append(self._indent() + '}')
        return '\n'.join(lines)
    
    def _emit_import(self, node: ImportStmt) -> str:
        """Emit import statement."""
        # For now, emit as comment - full module support later
        return f'// import "{node.module}" - modules not yet supported in JS target'


# ═══════════════════════════════════════════════════════════════════════════════
# CONVENIENCE FUNCTION
# ═══════════════════════════════════════════════════════════════════════════════

def compile_to_js(source: str, include_runtime: bool = True) -> str:
    """
    Compile realTinyTalk source to JavaScript.
    
    Args:
        source: realTinyTalk source code
        include_runtime: Whether to include the tt runtime shim
    
    Returns:
        JavaScript source code
    """
    import sys
    from pathlib import Path
    sys.path.insert(0, str(Path(__file__).parent.parent.parent.parent))
    
    from realTinyTalk.lexer import Lexer
    from realTinyTalk.parser import Parser
    
    # Lex
    lexer = Lexer(source)
    tokens = lexer.tokenize()
    
    # Parse
    parser = Parser(tokens)
    ast = parser.parse()
    
    # Emit
    emitter = JSEmitter(include_runtime=include_runtime)
    return emitter.emit(ast)


# ═══════════════════════════════════════════════════════════════════════════════
# CLI
# ═══════════════════════════════════════════════════════════════════════════════

if __name__ == '__main__':
    import argparse
    
    parser = argparse.ArgumentParser(description='Compile realTinyTalk to JavaScript')
    parser.add_argument('input', help='Input .tt file')
    parser.add_argument('-o', '--output', help='Output .js file (default: stdout)')
    parser.add_argument('--no-runtime', action='store_true', help='Omit runtime shim')
    
    args = parser.parse_args()
    
    # Read source
    with open(args.input, 'r', encoding='utf-8') as f:
        source = f.read()
    
    # Compile
    js = compile_to_js(source, include_runtime=not args.no_runtime)
    
    # Output
    if args.output:
        with open(args.output, 'w', encoding='utf-8') as f:
            f.write(js)
        print(f'Compiled to {args.output}')
    else:
        print(js)
